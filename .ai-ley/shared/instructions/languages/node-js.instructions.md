---
agentMode: general
applyTo: '**/*.{js,mjs,cjs}'
author: AI-LEY
description: Awaiting summary.
extensions:
- .md
guidelines: N/A
instructionType: general
keywords: []
lastUpdated: '2025-09-03T00:04:47.996154'
summaryScore: 3.0
title: Node Js.Instructions
version: 1.0.0
---

# Node.js Programming Instructions

Comprehensive Node.js development guidelines for AI coding assistants, emphasizing modern best practices, performance optimization, and maintainable code patterns.

## üß† Context

- **Language**: Node.js (18.x, 20.x LTS, 22.x Current)
- **Environments**: Server-side JavaScript runtime built on V8
- **Common Frameworks**: Express.js, Fastify, NestJS, Koa, Hapi
- **Package Managers**: npm, yarn, pnpm
- **Build Tools**: Webpack, Vite, esbuild, Rollup
- **Testing**: Jest, Mocha, Vitest, Tap, Ava

## üìÅ Project Structure

```text
{PROJECT_STRUCTURE_EXAMPLE}
```

## üîß General Guidelines

### Core Principles
- Write idiomatic, modern {LANGUAGE} following established conventions
- Prioritize code readability and maintainability over cleverness
- Implement clear separation of concerns and modularity
- Use consistent formatting with {FORMATTER_TOOL}
- Follow the principle of least surprise
- {LANGUAGE_SPECIFIC_PRINCIPLE_1}
- {LANGUAGE_SPECIFIC_PRINCIPLE_2}

### Modern Language Features
- {MODERN_FEATURE_1}
- {MODERN_FEATURE_2}
- {MODERN_FEATURE_3}
- {MODERN_FEATURE_4}

## üìú Code Style and Conventions

### Naming Conventions

```{LANGUAGE_SYNTAX}
// ‚úÖ Good: Use {NAMING_CONVENTION} for variables and functions
{VARIABLE_EXAMPLE}
{FUNCTION_EXAMPLE}

// ‚úÖ Good: Use {CLASS_NAMING_CONVENTION} for classes
{CLASS_EXAMPLE}

// ‚úÖ Good: Use {CONSTANT_NAMING_CONVENTION} for constants
{CONSTANT_EXAMPLE}

// ‚úÖ Good: Use descriptive names
{DESCRIPTIVE_NAMING_EXAMPLE}
```

### Function Design

```{LANGUAGE_SYNTAX}
// ‚úÖ Good: Pure functions with clear inputs/outputs
{PURE_FUNCTION_EXAMPLE}

// ‚úÖ Good: Use {DOCUMENTATION_STYLE} for documentation
{DOCUMENTED_FUNCTION_EXAMPLE}

// ‚úÖ Good: {LANGUAGE_SPECIFIC_PATTERN}
{PATTERN_EXAMPLE}
```

## üèóÔ∏è Architecture Patterns

### {PRIMARY_PARADIGM} Design

```{LANGUAGE_SYNTAX}
// ‚úÖ Well-structured {ARCHITECTURE_CONCEPT}
{ARCHITECTURE_EXAMPLE}
```

### {SECONDARY_PATTERN} Implementation

```{LANGUAGE_SYNTAX}
// ‚úÖ {PATTERN_DESCRIPTION}
{PATTERN_IMPLEMENTATION}
```

## üîÑ {ASYNC_CONCEPT} Programming

### {ASYNC_PATTERN} Best Practices

```{LANGUAGE_SYNTAX}
// ‚úÖ Good: Proper {ASYNC_HANDLING}
{ASYNC_EXAMPLE}

// ‚úÖ Good: {CONCURRENT_PATTERN}
{CONCURRENT_EXAMPLE}
```

### Error Handling

```{LANGUAGE_SYNTAX}
// ‚úÖ Custom error types
{ERROR_TYPE_EXAMPLE}

// ‚úÖ Comprehensive error handling
{ERROR_HANDLING_EXAMPLE}
```

## üõ°Ô∏è {MEMORY_CONCEPT} Management

### Efficient {RESOURCE_HANDLING}

```{LANGUAGE_SYNTAX}
// ‚úÖ {RESOURCE_PATTERN}
{RESOURCE_EXAMPLE}

// ‚úÖ {OPTIMIZATION_PATTERN}
{OPTIMIZATION_EXAMPLE}
```

## ‚ö° Performance Optimization

### Efficient Code Patterns

```{LANGUAGE_SYNTAX}
// ‚úÖ {PERFORMANCE_PATTERN_1}
{PERFORMANCE_EXAMPLE_1}

// ‚úÖ {PERFORMANCE_PATTERN_2}
{PERFORMANCE_EXAMPLE_2}

// ‚ùå Bad: {ANTI_PATTERN}
{BAD_EXAMPLE}

// ‚úÖ Good: {IMPROVED_PATTERN}
{GOOD_EXAMPLE}
```

## üß™ Testing Guidelines

### Unit Testing Best Practices

```{LANGUAGE_SYNTAX}
// {TEST_FILE_NAME}
{TESTING_EXAMPLE}

// ‚úÖ {TEST_PATTERN}
{TEST_IMPLEMENTATION}
```

### Integration Testing

```{LANGUAGE_SYNTAX}
// {INTEGRATION_TEST_EXAMPLE}
{INTEGRATION_IMPLEMENTATION}
```

## üõ†Ô∏è Development Environment

### Recommended Configuration

```{CONFIG_FORMAT}
// {CONFIG_FILE_NAME}
{CONFIGURATION_EXAMPLE}
```

### Essential Tools
- **Formatter**: {FORMATTER_TOOL} - {FORMATTER_DESCRIPTION}
- **Linter**: {LINTER_TOOL} - {LINTER_DESCRIPTION}
- **Type Checker**: {TYPE_CHECKER} - {TYPE_CHECKER_DESCRIPTION}
- **Build Tool**: {BUILD_TOOL} - {BUILD_DESCRIPTION}
- **Package Manager**: {PACKAGE_MANAGER} - {PACKAGE_DESCRIPTION}

## üîç Code Quality Standards

### Static Analysis

```{LANGUAGE_SYNTAX}
// ‚úÖ {QUALITY_PATTERN}
{QUALITY_EXAMPLE}
```

### Documentation Standards

```{LANGUAGE_SYNTAX}
// ‚úÖ {DOCUMENTATION_PATTERN}
{DOCUMENTATION_EXAMPLE}
```

## üö´ Common Pitfalls to Avoid

- **{PITFALL_1}**: {PITFALL_1_DESCRIPTION}
- **{PITFALL_2}**: {PITFALL_2_DESCRIPTION}
- **{PITFALL_3}**: {PITFALL_3_DESCRIPTION}
- **{PITFALL_4}**: {PITFALL_4_DESCRIPTION}
- **{PITFALL_5}**: {PITFALL_5_DESCRIPTION}

## üìö Essential Libraries

### Standard Library
```{LANGUAGE_SYNTAX}
{STANDARD_LIBRARY_EXAMPLE}
```

### Recommended Third-Party Libraries
- **{LIBRARY_1}**: {LIBRARY_1_DESCRIPTION}
- **{LIBRARY_2}**: {LIBRARY_2_DESCRIPTION}
- **{LIBRARY_3}**: {LIBRARY_3_DESCRIPTION}

## üö¶ AI Enforcement Summary

### Code Quality Rules
- ‚úÖ Enforce {QUALITY_RULE_1}
- ‚úÖ Require {QUALITY_RULE_2}
- ‚úÖ Block {ANTI_PATTERN_1}
- ‚úÖ Enforce {NAMING_CONVENTION_RULE}
- ‚úÖ Require {DOCUMENTATION_RULE}
- ‚úÖ Block {PERFORMANCE_ANTI_PATTERN}
- ‚úÖ Enforce {SECURITY_RULE}
- ‚úÖ Auto-fix {AUTO_FIX_RULE}

### Performance Enforcement
- üö´ Block {PERFORMANCE_VIOLATION_1}
- üö´ Block {PERFORMANCE_VIOLATION_2}
- ‚úÖ Promote {PERFORMANCE_BEST_PRACTICE_1}
- ‚úÖ Promote {PERFORMANCE_BEST_PRACTICE_2}

### Security Enforcement
- üîí Enforce {SECURITY_PRACTICE_1}
- üîí Block {SECURITY_VIOLATION_1}
- üîí Require {SECURITY_REQUIREMENT_1}

## üìñ References

- [{LANGUAGE} Official Documentation]({OFFICIAL_DOCS_URL})
- [{STYLE_GUIDE_NAME}]({STYLE_GUIDE_URL})
- [{BEST_PRACTICES_GUIDE}]({BEST_PRACTICES_URL})
- [{TESTING_GUIDE}]({TESTING_URL})
- [{PERFORMANCE_GUIDE}]({PERFORMANCE_URL})

---

## Template Usage Instructions

This template provides a comprehensive structure for creating language-specific instruction files. To use this template:

### 1. Replace Placeholder Variables

Replace all `{PLACEHOLDER}` variables with language-specific content:

#### Basic Information
- `{LANGUAGE}`: Programming language name (e.g., "Python", "Java", "Rust")
- `{LANGUAGE_EXTENSIONS}`: File extensions (e.g., "py,pyi", "java", "rs")
- `{VERSION_RANGE}`: Supported versions (e.g., "3.9+", "17+", "1.70+")
- `{LANGUAGE_SYNTAX}`: Code fence language identifier

#### Environment & Tools
- `{RUNTIME_ENVIRONMENTS}`: Where the language runs
- `{POPULAR_FRAMEWORKS}`: Major frameworks for the language
- `{PACKAGE_MANAGERS}`: Package management tools
- `{BUILD_TOOLS}`: Build and compilation tools
- `{TESTING_FRAMEWORKS}`: Testing libraries and frameworks

#### Code Examples
- `{PROJECT_STRUCTURE_EXAMPLE}`: Typical project directory structure
- `{VARIABLE_EXAMPLE}`: Variable declaration example
- `{FUNCTION_EXAMPLE}`: Function definition example
- `{CLASS_EXAMPLE}`: Class definition example
- All other `{*_EXAMPLE}` placeholders with actual code

#### Language-Specific Concepts
- `{NAMING_CONVENTION}`: Variable naming style (camelCase, snake_case, etc.)
- `{PRIMARY_PARADIGM}`: Main programming paradigm (OOP, Functional, etc.)
- `{ASYNC_CONCEPT}`: Asynchronous programming concept name
- `{MEMORY_CONCEPT}`: Memory management approach
- `{DOCUMENTATION_STYLE}`: Documentation format (JSDoc, docstrings, etc.)

#### Quality & Performance
- `{PITFALL_*}`: Common mistakes in the language
- `{QUALITY_RULE_*}`: Code quality enforcement rules
- `{PERFORMANCE_*}`: Performance-related patterns and anti-patterns
- `{SECURITY_*}`: Security best practices

### 2. Customize Sections

Adapt sections based on language characteristics:

- **Object-Oriented Languages**: Emphasize class design, inheritance, polymorphism
- **Functional Languages**: Focus on pure functions, immutability, higher-order functions
- **Systems Languages**: Highlight memory management, performance, safety
- **Scripting Languages**: Emphasize automation, text processing, rapid development

### 3. Add Language-Specific Sections

Consider adding specialized sections for:

- **Memory Management** (for manual memory management languages)
- **Concurrency** (for languages with built-in concurrency primitives)
- **Metaprogramming** (for languages with reflection/macros)
- **Interoperability** (for languages that interface with others)
- **Domain-Specific Features** (web frameworks, data science, etc.)

### 4. Quality Checklist

Ensure your completed instruction file includes:

- [ ] Complete front matter with correct file extensions
- [ ] Comprehensive introduction explaining scope and purpose
- [ ] Language-specific project structure example
- [ ] Practical code examples with good/bad comparisons
- [ ] Performance optimization specific to language characteristics
- [ ] Testing framework integration and best practices
- [ ] Development environment setup and tool recommendations
- [ ] AI enforcement rules suitable for automated linting
- [ ] Professional formatting with emoji section headers
- [ ] Balance between beginner accessibility and advanced techniques
- [ ] Links to authoritative language resources

### 5. Example Transformations

#### For Python:
```markdown
# Python Programming Instructions

- **Language**: Python (3.9+)
- **Environments**: CPython, PyPy, MicroPython
- **Common Frameworks**: Django, Flask, FastAPI, Pandas, NumPy
```

#### For Rust:
```markdown
# Rust Programming Instructions

- **Language**: Rust (1.70+)
- **Environments**: Native binaries, WebAssembly, Embedded
- **Common Frameworks**: Tokio, Actix, Axum, Serde, Clap
```

This template ensures consistency across all language instruction files while providing the flexibility to capture each language's unique characteristics and best practices.